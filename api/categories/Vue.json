{"name":"Vue","slug":"Vue","count":1,"postlist":[{"title":"Vue指令及基础知识","slug":"Vue-指令及基础知识","date":"2019-03-26T03:48:49.000Z","updated":"2019-03-26T02:12:09.000Z","comments":true,"path":"api/articles/Vue-指令及基础知识.json","excerpt":"","keywords":null,"cover":"/2019/03/26/Vue-指令及基础知识/3.png","content":"<h2 id=\"VUE\"><a href=\"#VUE\" class=\"headerlink\" title=\"VUE\"></a>VUE</h2><ul>\n<li>数据驱动:<strong>操作DOM</strong></li>\n<li>JS的数据类型 基本 和 引用</li>\n<li>改变原数组 —&gt; 数组的变异 <strong>pop push shif unshift reverse sort splice(n,m,x,y,z)</strong></li>\n<li>不改变原数组 —&gt; <strong>slice(n,m) concat indexOf join(‘+’) toString()</strong></li>\n<li>数组的迭代方法 <ul>\n<li>forEach </li>\n<li>map:renturn什么值，就往新数组添加新属性，若没有return值，就添加undefined</li>\n<li>filter<ul>\n<li>1)filter的回调函数中return值，若是true，则把当前迭代的项复制一份到新数组arr中</li>\n<li>2)filter的返回值是新数组arr</li>\n</ul>\n</li>\n<li>some:<ul>\n<li>1)回调函数中只要有一个回调函数返回的是true，则整个some 返回值就是ture</li>\n<li>2)只要某个项满足条件，就不在进行迭代</li>\n</ul>\n</li>\n<li>every:<ul>\n<li>1)回调函数，每一个都是true，every的返回值才是true</li>\n<li>2)换句话说就是只要有一个是false ，整个结果就是false</li>\n</ul>\n</li>\n<li>reduce((prev,next)=&gt;):结果就是最后一次迭代的return值</li>\n<li>find: 找到满足条件的第一项</li>\n<li>includes(item,index)从index索引值开始查找 找到就是true 找不到就是false</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"NODE基础命令\"><a href=\"#NODE基础命令\" class=\"headerlink\" title=\"NODE基础命令\"></a>NODE基础命令</h2><ul>\n<li>package.json 是项目的依赖表单</li>\n<li>dependencies:存储的都是生产环境的依赖</li>\n<li>devdependencies:储存的都是开发环境的依赖</li>\n<li>scripts:中存储的都是要执行的命令对应的代码</li>\n<li>npm run hello : 对应的要执行hello对应的代码</li>\n<li>npm i vue –save:在项目中添加依赖，安装依赖</li>\n<li>npm i yarn -g : 全局安装yarn，以后可以使用yarn代替npm 去安装一些依赖</li>\n</ul>\n<h2 id=\"VUE-M-V-VM\"><a href=\"#VUE-M-V-VM\" class=\"headerlink\" title=\"VUE - M-V-VM\"></a>VUE - M-V-VM</h2><ul>\n<li>1.vue 双向数据绑定 ；渐进式；框架</li>\n<li>2.视图 V 数据 M  VM</li>\n<li>3.视图改变 数据自动更新</li>\n<li>4.数据更新 视图自动更改</li>\n<li>5.渐进式: SPA 单页面开发<ul>\n<li>核心:vue.js  </li>\n<li>vue-router控制路由 </li>\n<li>vuex 处理数据</li>\n<li>axios 解决请求</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"声明式\"><a href=\"#声明式\" class=\"headerlink\" title=\"声明式\"></a>声明式</h2><ul>\n<li>编程式 forEach </li>\n<li>声明式 for() 编程式</li>\n</ul>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><ul>\n<li>框架:自己写的代码被框架调用 Vue React Angular BootStrap </li>\n<li>库: 自己调用库的代码</li>\n</ul>\n<h2 id=\"Vue的指令\"><a href=\"#Vue的指令\" class=\"headerlink\" title=\"Vue的指令\"></a>Vue的指令</h2><ul>\n<li>1.v-model: 是vue的指令 name是实例的变量 指令是指让对应的元素做某件事</li>\n<li>2.v-text : 展示对应的文本</li>\n<li>3.v-once : 对应的标签只渲染一次 1~3指令都是行内属性</li>\n<li>4.v-html : 把值中的标签渲染出来</li>\n<li>5.v-cloak : <strong>解决渲染闪烁问题</strong><pre><code>[v-cloak] {display: none;} \n&lt;div v-cloak&gt;{{ message }}&lt;/div&gt;</code></pre></li>\n<li>6.v-show : 控制元素的display:ngone 属性</li>\n<li>7.v-on:click : 给元素绑定事件 简写 <code>@click = &#39;fn&#39;</code></li>\n<li>8.v-keyup.enter = ‘fn’ : 给元素绑定键盘事件</li>\n<li>9.v-bind:绑定样式 对象 路径 缩写: <code>:</code></li>\n<li>10.v-for : 循环显示元素的,可以循环数组，也可以循环<code>对象、字符串、数字</code> ，v-for优先级比v-if/else的优先级高，先渲染v-for</li>\n<li>11.v-if / v-else-if /v-else :直接不加载元素,先做循环再做判断<h3 id=\"v-model指令\"><a href=\"#v-model指令\" class=\"headerlink\" title=\"v-model指令\"></a>v-model指令</h3></li>\n<li><code>实现 数据和视图 双向绑定 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt;等表单元素和components组件</code></li>\n<li>单个复选框，绑定到布尔值：  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CheckBox 多个复选框,绑定到同一个数组：<code>check = []</code><br>  <input type=\"checkbox\" value=\"CSS\" v-model=\"check\"> CSS<br>  <input type=\"checkbox\" value=\"HTML\" v-model=\"check\">HTML<br>  <input type=\"checkbox\" value=\"JS\" v-model=\"check\">JS</li>\n<li>check 若为 [] <code>一个数组</code>  则3个input框能联系在一起,选择input框，则会在数组中push表单框中的value值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">radio 单选框</span><br><span class=\"line\">\t&lt;!-- 多个input绑定同一个变量即可 --&gt;</span><br><span class=\"line\">\t&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;1&quot;/&gt;🍎</span><br><span class=\"line\">\t&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;2&quot;/&gt;🍌</span><br><span class=\"line\">\t&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;3&quot;/&gt;🍊</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"v-model实现数据双向绑定的原理\"><a href=\"#v-model实现数据双向绑定的原理\" class=\"headerlink\" title=\"v-model实现数据双向绑定的原理\"></a>v-model实现数据双向绑定的原理</h2><h4 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h4><ul>\n<li>获取数据，当属性依赖于其他data中属性时，其他数据改变，才会触发这个方法，但必不会触发set方法</li>\n<li>最终值是由get方法决定的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class=\"line\">\tget()&#123;return 123&#125;,</span><br><span class=\"line\">    set(val)&#123;</span><br><span class=\"line\">        console.log(val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">obj.name = 333;</span><br><span class=\"line\">console.log(obj.name)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"set方法\"><a href=\"#set方法\" class=\"headerlink\" title=\"set方法\"></a>set方法</h4><ul>\n<li>使用v-model:进行数据的双向绑定 只有点击改变值的时候，才会触发这个方法，触发这个方法必然触发了get方法</li>\n<li><img src=\"/2019/03/26/Vue-指令及基础知识/3.png\" alt=\"get与set的区别\"></li>\n</ul>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><h3 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h3><ul>\n<li>self: 只有点击元素本身的时候才触发</li>\n<li>stop:阻止冒泡</li>\n<li>prevent:阻止默认事件</li>\n<li>once: 对应的函数只触发一次</li>\n<li>capture: 让事件在捕获阶段触发</li>\n<li>passive : 优先执行默认事件，在执行绑定的函数，优化移动端性能，只对滚动行为有效<h3 id=\"v-model修饰符\"><a href=\"#v-model修饰符\" class=\"headerlink\" title=\"v-model修饰符\"></a>v-model修饰符</h3></li>\n<li>number : 将字符串转化为数字 类似 parsefloat的效果</li>\n<li>trim : 自动去除首尾空格</li>\n</ul>\n<h2 id=\"自定义全局键码\"><a href=\"#自定义全局键码\" class=\"headerlink\" title=\"自定义全局键码\"></a>自定义全局键码</h2><p><code>Vue.config.keyCodes.f2 = 113</code> =&gt; 在模板中可以这样使用 <code>@keyup.f2 = fn&#39;&#39;</code>·</p>\n<h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;money | changeM&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>管道符前边是要处理的数据，后边是处理的参数，最终展示的是函数的返回值</li>\n<li>过滤器是可以连续使用的，下一个过滤器的返回值，是上一个过滤器的返回值</li>\n<li>全局过滤器和私有过滤器，全局过滤器任何组件都可以调用，私有过滤器只有定义过滤器的组件可以调用</li>\n<li>filter 中的方法 可以重名，不会被冲掉，但尽可能不要重名<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.filter(&apos;过滤器名称&apos;，function()&#123;&#125;) 全局过滤器</span><br><span class=\"line\">\tconsole.log(this) //=&gt; this 指向window</span><br><span class=\"line\">在vm实例中定义</span><br><span class=\"line\">filters:&#123;</span><br><span class=\"line\">\t&apos;过滤器名称&apos;:functon()&#123;&#125;</span><br><span class=\"line\">&#125; 私有过滤器</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"侦听器-Watch\"><a href=\"#侦听器-Watch\" class=\"headerlink\" title=\"侦听器 Watch\"></a>侦听器 Watch</h2><ul>\n<li>异步用监听,但是比较耗性能，能够深层监听，能够返回oldV 和 newV 两个值供实例调用</li>\n<li>深层监听的属性必须是有set和get方法的属性值</li>\n<li>当监听一个数组的时候，若数组地址不发生改变，那么不会触发watch的方法</li>\n<li>Watch还可以监听到路由的变化</li>\n<li>具有局限性，当监听的数据过多时，不适合使用watch方法</li>\n</ul>\n<h2 id=\"计算属性-Computed\"><a href=\"#计算属性-Computed\" class=\"headerlink\" title=\"计算属性 Computed\"></a>计算属性 Computed</h2><ul>\n<li><p>同步用计算属性，但依赖性太强，用到get/set方法</p>\n</li>\n<li><p>定义的方法，挂载在vm的实例，不能跟methods和data重名，但是现在不报错，但是不能用，因为methods中的方法会把computed中的方法冲掉</p>\n</li>\n<li><p>只要name不发生改变，name2就不发生改变</p>\n</li>\n<li><p>name2用到谁，就依赖谁</p>\n</li>\n<li><p>conputed计算属性，具有缓存机制，若数据发生改变，会重新计算属性，若只是重复调用，则不会触发computed方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">\tname2()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name.split(<span class=\"string\">''</span>).rerverse().join(<span class=\"string\">''</span>)</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tname3()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">123</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span>(val)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 给name3赋值的时候会触发, set函数</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// val 是外界</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>computed / watch / methods 三者的区别</p>\n<ul>\n<li><code>computed</code> : 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算，主要当做属性来使用</li>\n<li><code>watch</code> : 一个对象，键是需要观察的表达式，值是对应的回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是<code>methods</code>和<code>computed</code>的结合体</li>\n<li><code>methods</code> : 表示一个具体的操作，主要书写业务逻辑<h2 id=\"自定义全局指令\"><a href=\"#自定义全局指令\" class=\"headerlink\" title=\"自定义全局指令\"></a>自定义全局指令</h2></li>\n</ul>\n</li>\n<li><p>使用directive定义全局的指令</p>\n</li>\n<li><p>其中参数1：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 -v 前缀</p>\n</li>\n<li><p>但是在调用的时候，必须在指令名称前加上 v- 前缀 进行调用</p>\n</li>\n<li><p>参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>,&#123;</span><br><span class=\"line\">\tbind:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>)</span>&#123;  =&gt;每当指令绑定到元素身上的时候，会立即执行这个bind函数，只执行一次</span><br><span class=\"line\">\t\t<span class=\"comment\">//1.注意：在每个函数中，第一个参数永远是el，表示被绑定的那个元素，这个el参数以一个原生JS对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//2.在元素刚绑定指令的时候，还没有插入到DOM中，这时候，调用focus方法没有起作用</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//3.因为，一个元素只有插入到DOM中，才能获取焦点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//el.focus()</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tinserted:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>)</span>&#123;  =&gt;表示元素被插入到DOM中的时候，触发这个inserted函数，触发一次</span><br><span class=\"line\">\t\tel.focus()</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tupdated:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>)</span>&#123;  =&gt;每当VNode更新的时候，会执行updated函数，可能会被触发多次 </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自定义指令简写:<pre><code class=\"Vue.directive(&#39;focus&#39;,function(el,binding){})\"></code></pre>\n</li>\n<li>钩子函数的参数:<ul>\n<li>指令钩子函数会被传入以下实参</li>\n<li>1.el : 指令所绑定的元素，可以用来直接操作 DOM </li>\n<li>2.binding:<ul>\n<li>name: 指令名，<code>不包括 v- 前缀</code>;</li>\n<li>value:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 <code>2</code>;</li>\n<li>expression:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 <code>&quot;1 + 1&quot;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","text":"VUE数据驱动:操作DOMJS的数据类型 基本 和 引用改变原数组 —&gt; 数组的变异 pop push shif unshift reverse sort splice(n,m,x,y,z)不改变原数组 —&gt; slice(n,m) concat indexOf joi","link":"","raw":null,"photos":[],"categories":[{"name":"Vue","slug":"Vue","count":1,"path":"api/categories/Vue.json"}],"tags":[{"name":"指令","slug":"指令","count":4,"path":"api/tags/指令.json"}]}]}